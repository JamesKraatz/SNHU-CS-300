# SNHU-CS-300

•	What was the problem you were solving in the projects for this course?
This course dealt with data structures and how to manage them. These data structures ranged from simple vectors through hash tables to binary trees. In addition to exposure to the data structures, we put together pseudocode to demonstrate our understanding of the insertion, deletion, sorting, and searching for data processes involved with these structures.
•	How did you approach the problem? Consider why data structures are important to understand.
When choosing a data structure, it is best to consider the data and how it will be accessed. If the data needs to be accessed via a sorted order, then hash tables or trees are best choices. If data is to be accessed in relation to the sequence the data was placed in the structure, arrays and vectors are best choices. One key thing to remember is the “Order” of the data structure for your access. 
•	How did you overcome any roadblocks you encountered while going through the activities or project?
Most roadblocks are overcome by first identifying the roadblock itself. In the area of compiler errors, reading and understanding the error and reviewing the code pointed to by the error. If needed, expanding your solution search using Google and asking your peers helps. Functional problems are helped with multitudes of “print” statements displaying a status of the code. This helps show how if the processes are performing as expected and provides clues as to why not.
•	How has your work on this project expanded your approach to designing software and developing programs?
I feel the projects have pushed the usage of pseudocode as an important precursor to coding. I believe this is one of the effective methods of planning your application. I definitely believe that any application needs to be planned before any coding just starts. This term reinforces this belief with the amount of pseudocode we wrote for the final project before actually writing any code. Additionally, the different data structures and the work on understanding them expanded the “code” tools to work with. 
•	How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
This project has pushed me to plan my application more, keep my methods shorter, try to use more descriptive names, and to try and implement simpler more understandable algorithms.
